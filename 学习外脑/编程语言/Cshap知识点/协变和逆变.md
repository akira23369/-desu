#编程语言/Csharp #永久 

[C#语法之泛型，及协变和逆变深入讲解。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV13N4y1Y7Tg/?spm_id_from=333.337.search-card.all.click&vd_source=2f348893e98a838d97300d2bf728b18b)

协变和逆变是用来修饰泛型的
协变：out   表明修饰的T只能作为**返回值**来使用
逆变：in      表明修饰的T只能作为**参数**来使j用
只有**泛型接口**和**泛型委托**能使用

```csharp
interface ISpeak<out T> { }
class Speak : ISpeak { }

Speak<Son> s1 = new Speak<Son>();
Speak<Father> s2 = new Speak<Father>();

// 无论如何都不行
Speak<Father> s3 = new Speak<Son>();
Speak<Father> s4 = s1;

// 可以使用协变和逆变实现下面功能
ISpeak<Father> s5 = new Speak<Son>();
ISpeak<Father> s6 = s1;
```

**协变和逆变主要是来解决泛型类型在继承过程中出现的类型安全问题**
```csharp
class Father { }
class Son : Father { }
interface ISport<T>
{
    void Method1(T val);
    T Method2();
}
class Sport<T> : ISport<T>
{
    public void Method1(T val) { }
    public T Method2()
    {
        return default(T);
    }
}
class Program
{
    static void Main(string[] args)
    {
        ISport<Father> sport = new Sport<Son>();
        var tmp = sport.Method2();      // 安全   父类要求返回一个<Father>  子类实现却给了我一个<Son> 
        sport.Method1();                // 不安全 子类实现要求传入一个<Son>  父类参数却给了我一个<Father>
    }
}
```

泛型委托例子

```csharp
public delegate void TestIn<in T>(T a);
public delegate T TestOut<out T>();
class Father { }
class Son : Father { }



TestOut<Son> os = () =>
{
    return new Son();
};
TestOut<Father> of = os;

TestIn<Father> inf = (val) =>
{
};
TestIn<Son> ins = inf;      // 实际上面inf调用需要Father, ins(new Son())这距执行可以传一个son进入到inf()中
```

