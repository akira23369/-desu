#永久 #内功/设计模式

# 总结:
- **单一职责原则**: 一个类**只处理自己应该处理的内容**, 不应该啥都写在一起
- **开闭原则**: 对拓展开放, 对修改关闭. **新功能应该尽量通过增加代码,而不是改代码**
- **里氏替换原则**:  **父类装子类**
- **依赖倒转原则**: 不依赖具体实现, **要依赖抽象(接口)**
- **迪米特法则**: 一个类尽量减少对别的类的了解, **尽量少用别的类与自己关联**
- **接口隔离原则**: **一个接口一个行为**, **不要一个接口n个行为**
- **合成符用原则**: 除非设计上需要继承, 否则**尽量用组合复用的形式**


## 单一职责原则
 SRP(Single Responsibilities Principle)的定义：就一个类而言，应该仅有一个引起它变化的原因。简而言之，就是功能要单一。  

## 开闭原则
  
1. OCP(Open-Close Principle)的定义：就是说软件实体(类，方法等等)应该可以扩展（扩展可以理解为增加），但是不能在原来的方法或者类上修改，也可以这样说，对增加代码开放，对修改代码关闭。  
2. OCP的两个特征： 对于扩展（增加）是开放的，因为它不影响原来的，这是新增加的。对于修改是封闭的，如果总是修改，逻辑会越来越复杂。

## 里氏替换原则

## 依赖倒转原则
1. DIP(Dependence Inversion Principle)的定义：抽象不应该依赖细节，细节应该依赖于抽象。简单说就是，我们要针对接口编程，而不要针对实现编程。  
2. 高层模块不应该依赖低层模块，两个都应该依赖抽象，因为抽象是稳定的。抽象不应该依赖具体（细节），具体（细节）应该依赖抽象。

## 迪米特原则

1. 迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。  
2. 关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。  
3.  外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。  
 **小结**：迪米特法则的初衷是降低类之间的耦合，实现类型之间的高内聚，低耦合，这样可以解耦。但是凡事都有度，过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

## 接口隔离原则
接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。
**举例** : 飞, 跑, 走  都是移动行为, 但是应该把它们分成一个单独接口,让别人选择使用


## 合成复用原则

1. 组合复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。
2. 要使用好组合复用原则，首先需要区分”Has—A”和“Is—A”的关系。 “Is—A”是指一个类是另一个类的“一种”，是属于的关系，而“Has—A”则不同，它表示某一个角色具有某一项责任。导致错误的使用继承而不是聚合的常见的原因是错误地把“Has—A”当成“Is—A”.例如：鸡是动物，这就是“Is-A”的表现，某人有一个手枪，People类型里面包含一个Gun类型，这就是“Has-A”的表现。
**总结**:组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏替换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。


[C#设计模式之总结篇 - 可均可可 - 博客园 (cnblogs.com)](https://www.cnblogs.com/PatrickLiu/p/8287784.html)